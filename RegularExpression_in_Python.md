# **Regular Expression in Python**

## Regular Expression 
 본 내용은 [다음](https://docs.python.org/3/howto/regex.html#regex-howto)을 번역했으며 파이썬 re모듈의 기본을 다룬다. 심화는 다음 기회에 또 번역하기로 한다.

>Author | A.M. Kuchling <amk@amk.ca>

>이 문서는 파이썬의  re 모듈을 활용한 정규표현식의 입문 튜토리얼이다. 파이썬 [Library Reference](https://docs.python.org/3/library/re.html#re-objects)보다 더 친절한 *파이썬 정규표현식 입문용*에 해당된다.

### 소개
정규표현식(RE, regexes, regex pattern)이란 기본적으로 파이썬에 내장된 매우 작고, 특수화된 프로그래밍 언어이며 `re` 모듈을 통해 사용가능하다.
이 작은 언어를 사용함으로써, 매칭(match)하고 싶은 가능한 문자열 집합을 찾을 수 있는 규칙을 정할 수 있다. 이 집합에는 영어 문장, 이메일 주소, TeX 명령어를 포함한 당신이 원하는 모든 것이 포함될 수 있다. 그러면 당신은 "이 문자열에서 패턴을 매칭하는 부분이 있나?" 혹은 "이 문자열이 패턴을 매칭하나"와 같은 질문을 던질 수 있다.
또는 RE를 사용해서 문자열을 변경하거나 다양한 방법으로 쪼개는 것도 가능하다.

정규표현식 패턴은 연속된 바이트코드로 컴파일된 후 그 바이트코드가 C로 작성된 매칭 엔진에 의해 실행되는 방식으로 사용된다. 정규표현식에 익숙해진다면 매칭 엔진이 주어진 정규표현식을 어떻게 처리할지와 더 빠르게 작동하는 바이트코드를 입력할 수 있는 특정한 방법에 관심을 두어야 한다. 
그 **최적화**는 여기서 다루지 않는데 그 이유는 그런 영역은 매칭 엔진의 내부에 대한 수준 높은 이해가 필요하기 때문이다.

정규표현식 언어는 상대적으로 작고 조건이 까다로워서 모든 가능한 문자열 가공작업이 정규표현식을 통해 가능한 것은 아니다.
정규표현식으로 가능하다 하더라도, 이때 정규표현식은 매우 복잡해진다. 이런 경우에는 이 작업을 할 파이썬 코드를 직접 코딩하는 것이 나을 수도 있다.  파이썬 코든는 고도화된 정규표현식에 비해 느릴 수는 있지만, 아마 더 이해하기는 쉬울 것이다.

### 간단한 패턴
 우리는 가능한 가장 쉬운 정규표현식을 배우는 것부터 시작할 것이다.
 정규표현식은 문자열에서 작동하기 때문에, 우린 *문자*를  매칭하는 가장 일반적인 작업부터 시작할 것이다.

 정규표현식에 관한 컴퓨터 과학(결정론적인 또는 비결정론적인 유한 오토마타)에 대해 더 공부하고 싶다면 `writing compiler`에 관한 텍스트북을 찾아보도록 하자.

### 문자 매칭하기
대부분의 문자와 글자는 간단하게 자기 자신을 매칭할 것이다. 예를 들어 정규표현식 `test`은 `test`라는 문자열을 정확히 매칭할 것이다.(심지어는 `Test`와 `TEST` 또한 매칭하게 하는 case-insensitive 모드도 가능하게 할 수 있다. 조금 있다가 알아보도록 한다.)

이 규칙에는 예외가 있는데 어떤 글자들은 특별한 __*metacharacter*__로서 자기 자신을 매칭하지 않는다. 대신 이 문자들은 어떤 일반적이지 않은 것들이 매칭되도록 표시하거나, 자신을 반복하거나 의미를 바꿈으로써 정규표현식의 다른 부분에 영향을 미친다. 이 문서의 상당 부분은 다양한 metacharacter와 그것의 역할에 대해 이야기하는 데 할애된다.

모든 metacharacter들은 다음과 같다. 이들의 의미는 나머지 부분에서 다룰 것이다.

```
.  ^  $  *  +  ?  {  }  [  ]  \  |  (  )
```

맨 처음 알아볼 metacharacter는 `[`와 `]`이다. **글자 집합**을 특정지을 때 사용되는데, 글자 집합이란 당신이 매칭하고 싶은 문자들의 묶음이라고 할 수 있다. 글자는 개별적으로 나열될 수 있고, 글자 두 개와 그 사이의 범위를 표현하는 `'-'`가 들어감으로써 표현될 수 있다. **예를 들어, `[abc]`는 `'a'`, `'b'`, `'c'` 이 세 글자를 매칭할 것이고 `[a-c]`와 같다.**
만약 소문자 영어 글자를 모두 표현하고 싶다면 당신의 정규표현식은 `[a-z]`가 될 것이다.


metacharacter는 글자 집합 안에서는 active하지 않다. 예를 들어 `[akm$]`는 `'a'`, `'k'`, `'m'` 또는 `'$'`를 매칭할 것이다. `'$'`는 일반적으로 metacharacter지만, 글자 집합 안에서는 본연의 특수한 성질을 잃게 된다. 즉, 일반 문자 취급당한다.

반대로 글자 집합에 없는 글자를 매칭하고 싶을 때는 집합을 *보완하면(complementing)* 된다. 이것은 글자 집합에서 맨 앞에 `'^'`를 붙이면 가능하다. 이렇게 하면 글자 집합에 포함되지 않는 모든 글자가 `'^'`를 매칭할 것이다. **예를 들면 `[^5]`는 `'5'`를 제외한 모든 글자를 매칭할 것이다.**

아마 가장 중요한 metacharacter는 backslash, `\`일 것이다. 파이썬 문자열 상수에서 `\`에는 다양한 문자들이 따라 붙어 여러 특수 문자(special sequence)를 표현할 수 있다. 또한 backslash는 모든 metacharacter들의 의미를 백지화(**escape**)할 수 있고 그렇게 해서 당신은 metacharacter들을 패턴에서 매칭할 수 있다. 예를 들어, 당신이 `[`나 `\`를 매칭하고 싶다면, 그 문자들 앞에 backslash를 붙여서 그들의 특수한 의미를 없앨 수 있다. `\]`나 `\\`처럼 말이다.

`\`로 시작하는 어떤 특수문자들은 자주 사용되는 숫자 집합이나 문자 집합, 공백이 아닌 모든 것들의 집합을 나타낼 수 있다.

예를 보도록 하자. `\w`는 모든 alphanumeric글자를 매칭한다. 정규표현식 패턴을 바이트로 표현하면 이것은 `[a-zA-Z0-9_]`와 동일하다. 만약 정규표현식 패턴이 문자열이면 `\w`는 `unicodedata`모듈에서 제공된 unicode 데이터베이스에 표현된 모든 문자를 매칭할 것이다. 당신은 정규표현식을 컴파일할 때 `re.ASCII`를 통해 더 엄격하게 `\w` 문자열 패턴을 사용할 수 있다.

다음 특수문자 목록은 불완전하다. unicode 문자열 패턴에 사용되는 특수문자의 완벽한 목록과 확장된 글자 정의를 원한다면, 표준 파이썬 라이브러리 래퍼런스의 [Regular Expression Syntax](https://docs.python.org/3/library/re.html#re-syntax)의 나머지 부분을 보도록 하라. 일반적으로 unicode의 다양한 버전들은 [unicode database](ftp://ftp.unicode.org/)에 있는 적절한 범주 안의 모든 글자를 매칭한다.

```
\d
    모든 십진수 숫자를 매칭한다. [0-9] 글자집합과 동일하다.
\D
    십진수 숫자를 제외한 모든 문자를 매칭한다. [^0-9]와 동일하다.

\s
    모든 공백문자와 매칭한다. [\t\n\r\f\v]와 동일하다.
\S
    공백문자를 제외한 모든 문자와 매칭한다. [^\t\n\r\f\v]와 동일하다.

\w
    모든 alphanumeric 문자와 매칭한다. [a-zA-Z0-9_]와 동일하다.
\W
    alphanumeric 문자를 제외한 모든 문자와 매칭한다. [^a-zA-Z0-9_]와 동일하다.
```

이 특수문자들은 글자 집합 안에서 정의될 수 있다. 예를 들어 `[\s,.]`은 모든 공백문자나 `','`, `'.'`를 매칭할 것이다.

이 섹션에서의 마지막 metacharacter는 `.`이다.  이 글자는 newline만을 제외한 모든 글자와 매칭되며, newline도 포함할 수 있는 대안적인 방법(`re.DOTALL`)도 존재한다. `'.'`는 주로 어떤 글자"라도 매칭하고 싶을 때 사용된다.


### 반복되는 것들
다양한 글자 집합을 매칭하는 것은 정규표현식이 할 수 있는 첫 번째 일이지만 문자열에 쓰기에는 아직 충분한 방법은 아니다.  그러나, 그것이 정규표현식의 유일한 추가기능이었다면, 정규표현식은 이렇게 발전하지 않았을 것이다. **정규표현식의 다른 능력은 당신이 특정한 정규표현식을 몇 번이고 반복할 수 있다는 것이다.**

우리가 살펴 볼 글자들을 반복하는 첫 번째 metacharacter는 `*`이다. `*`는 글자 `*`를 매칭하지 않는다. 대신, ***(asterisk)는 이전 글자가 단 한 번이 아닌 0번이나 그 이상 매치되도록 특정짓는다.**

예를 들어 `ca*t`는 `ct`( `a`가 0개), `cat` (`a`가 1개), `caaat`(`a`가 3개)가 매칭된다. RE 엔진은 내부적으로 C 언어의 `int` 타입의 사이즈로 파생되어 반복될 수 있는 횟수에 있어 다양하게 제한을 두는데, 20억개 이상의 `a`를 매칭하는 것은 막게 되어 있다. 그런데 패턴은 보통 그 정도로 많이 매칭될 일은 없다

`*`로 반복하는 방식은 __*greedy*__하다. RE를 반복할 때,  매칭엔진은 가능한 많은 횟수로 반복하려 할 것이다. 만약 패턴의 뒷부분이 매치가 되지 않으면 매칭 엔진은 돌아와서 더 적은 횟수로 반복할 것이다.

한 계단씩 천천히 살펴보면 이것이 더 명확하게 이해가 된다. `a[bcd]*b`라는 예를 보자. 이 식은 `'a'`를 매칭하고, `[bcd]`를 최소 0번 매칭하고, 마지막으로 `'b'`로 끝난다. 이제 이 정규표현식이 `abcbd`라는 문자열을 매칭해야 한다고 생각해보자.

**Step** | **Matched** | **Explanation**
----------|-------|------------
1    | `a`     | 식 안의 `a`가 매칭된다.
2    | `abcbd` | 엔진이 `[bcd]*`를 매칭하고, 가능한 더 확장해서 문자열 끝까지 가게 된다.
3    | __*실패*__ | 엔진이 `b`를 매칭하려 하지만, 현재 위치는 문자열의 끝이라서 실패하게 된다.
4    | `abcb`     | 돌아가서 `[bcd]*`는 그 전 문자까지만 매칭한다.
5    | __*실패*__ | `b`를 다시 매칭하려 하지만, 현재 위치는 `'d'`라는 마지막 글자이다.
6    | `abc`   | 다시 돌아가서 `[bcd]*`는 `bc`만 매칭한다.
7    | `abcb`   | `b`를 다시 매칭해본다. 이번에는 현재 위치의 글자가 `b`이므로 다음 매칭이 성사된다.

이제 정규표현식의 끝에 이르렇고 `abcb`가 매칭되었다. 위의 예는 어떻게 매칭 엔진이 처음에 가능한 멀리까지 나아가고, 다음 매칭이 없으면 점진적으로 돌아오고, 다시 나머지 식을 반복적으로 실행하는지를 증명한다. 이 식은 `[bcd]*`가 0번 매치될 때까지 돌아올 것이고, 결과적으로 모두 실패하면 엔진은 주어진 문자열이 정규표현식을 전혀 만족시키지 않는다고 결론지을 것이다.

다른 반복 metacharacter는 `+`가 있다. **`+`는 1번 또는 그 이상 매칭한다.** `*`와 `+`의 차이를 정확히 알도록 하자. `*`는 __*0번 또는 그 이상*__되기 때문에 반복되는 무언가가 아예 없어도 매칭조건이 완성된다. 반면에 `+`는 __*적어도 1번*__은 반복되어야 한다. 위의 예를 들자면 `ca+t`는 `cat`(`a`가 1번), `caaat`(`a`가 3번)에는 매칭되지만 `ct`는 매칭하지 못한다.

반복 식별자(repeating qualifier)는 두 개가 더 있다. 
먼저 물음표, `?`는 __*0번 또는 1번만*__ 매칭한다. 이것은 주로 무언가 선택적인 것을 표시할 때 사용한다고 생각하면 된다. 예를 들어, `home-?brew`는 `homebrew`나 `home-brew`를 매칭한다.

마지막으로 가장 복잡한 반복 식별자는 `{m, n}`이다. *m*과 *n*은 십진수 숫자이다. 이 식별자의 뜻은 __적어도 *m*번 매칭되고 최대(at most) *n*번 반복__된다는 것을 의미한다. 예를 들어, `a/{1,3}b`는 `a/b`, `a//b`, `a///b`를 만족한다. 그렇지만 `ab`나 `a////b`는 만족하지 않는다.

환원주의자 기질이 있는 독자들이라면 아마 나머지 3개의 다른 식별자가 `{}`식을 통해 모두 표현가능하다는 것을 알아챘을 것이다. `{0,}`는 `*`와 같고, `{1,}`는 `+`와 같으며, `{0,1}`는 `?`와 같다.

그래도 가급적이면 `*`, `+`, `?`를 사용하면 좋다. 이것들이 단순하고 더 짧으며 더 가독성 있기 때문이다.


### 정규표현식 사용하기

이제 우리는 간단한 정규표현식을 살펴봤다. 그러면 파이썬에서는 실제로 어떻게 이것들을 사용할 수 있을까?
`re` 모듈에서는 정규표현식 엔진에 대한 인터페이스를 제공하며, RE를 객체로 컴파일한 뒤 매칭을 할 수 있도록 하고 있다.

### 정규표현식 컴파일 하기
정규표현식은 패턴 객체로 컴파일되는데 이 객체는 패턴 매칭을 찾는다거나 문자열 대체와 같은 다양한 작업을 할 수 있는 매소드를 지원한다.

```python
import re
p = re.compile('ab*')
p
```

`re.compile()`은 또한 선택적 __*flag*__인자를 받을 수 있고 이를 통해 다양한 특성과 문법 변화를 줄 수 있다. 가능한 인자에 대한 설명은 나중에 하도록 하고, 대신 하나만 살펴보도록 하겠다.

```python
p = re.compile('ab*', re.IGNORECASE)
```

이 식은 `re.compile()`에 문자열로 전달된다. 정규표현식은 문자열로 취급받는데 그 이유는 정교표현식은 파이썬 언어의 핵심적인 부분이 아니고, 그것들을 표현하기 위한 특별한 문법이 만들어지지 않았기 때문이다.(RE를 전혀 필요로 하지 않는 어플리케이션도 있기 때문에 명세 언어(language specification)에 그것들을 포함해서 우쭐대지 않아도 된다.) 대신 `re` 모듈은 `socket`이나 `zlib`처럼 단순히 파이썬에 내장된 C 확장 모듈에 불과하다.

RE를 문자열로 둠으로써 파이썬 언어는 더 간결해졌지만 다음에 이야기할 주제인 단점도 가지게 되었다.

### Backslash 전염병











#-------------------------------------------------
#<다른 영역>
#-------------------------------------------------

### Preview
> 파이썬에서의 정규표현식은 'Regular expression'의 두문자어인 re 모듈을 사용할 수 있다. Perl 언어의 정규표현식과 비슷하다.
> 쓰이는 패턴과 문자열은 유니코드, 8비트 스트링 모두에서 사용될 수 있다.
> 그러나, 유니코드와 8비트 문자열을 같이 사용할 수 없다. 다시 말해, 유니코드 문자열에서 바이트 단위 패턴으로 매칭(match)할 수 없고, 그 반대도 마찬가지다.
> 비슷한 예로, 문자열 대체를 하기 위해서는 대체 문자열은 패턴과 원 문자열과 같은 타입이어야 한다.

> 정규표현식은 backslash character(`'\'`)를 사용해서 특별한 형식을 표시하거나 특수문자의 특수한 의미를 부각시키지 않고 특수문자를 사용할 수 있도록 한다.
> 이 방식이 문자열 상수를 같은 목적으로 같은 단어를 사용할 때 충돌하게 된다. 예를 들면, `'\'` 상수를 매칭하기 위해서는 패턴에 `'\\\\'`라고 입력해야 하는데 정규표현식에서는 '`\\`'라고 써야 하며, 그 각각의 backslash는 파이썬 문자열 상수에서 `'\\'`라고 표현되어야 하기 때문이다.

> 해결책은 파이썬의 정규표현식 패턴에서의 raw 문자열 표기방식을 사용하는 것이다. 맨 앞에 `'r'`으로 표시된 문자열에서  (ex r'good day\\ok!') backslash는 어떤 특수한 방식으로도 처리되지 않는다. 다시 말해, `r'\n'`는 `'\'`와 `'n'`, 두 글자로 이루어진 문자열이며, 반면 `'\n'`은 newline을 의미하는 한 글자짜리 문자열이다. 일반적으로 정규표현식에서의 패턴은 이 raw 문자열 표기방식이 사용된 파이썬 코드로 표현될 것이다.

> 대부분의 정규표현식 작동방식이 *compiled regular expression*에서는 모듈수준의 함수와 메소드가 사용가능하다는 것을 아는 것이 중요하다. 여기서 함수는 당신에게 regex 객체를 먼저 컴파일하기 요구하지 않는 지름길에 불과하고, 대신 더 미세한 조정을 할 수 있는 인자를 놓치게 된다.

<br><br>
### 정규표현식 문법
> 정규표현식은 자신을 매칭하는 문자열의 집합을 명시한다. 이 모듈의 함수들은 특수한 문자열이 주어진 정규표현식을 만족하는지 체크하는 것이다. (또는 주어진 정규표현식이 특정한 문자열을 매칭하는지 확인할 것이다. 결국은 같은 일을 하는것이다.)

> 정규표현식은 서로 연결되어 새로운 정규표현식을 형성할 수 있다. 만약 *A*와 *B*가 모두 정규표현식이면 *AB* 또한 정규표현식이다. 일반적으로, 문자열 *p*가 A를 매칭하고 다른 문자열 *q*가 *B*를 매칭할 때, 문자열 *pq*는 *AB*를 매칭할 것이다. 이것은 *A*또는 *B*가 서로에게서 우선순위에서 밀리거나 숫자화된 그룹 참조를 가지고 있지 않은 이상 유효하다.
> 그러므로 복잡한 표현식은 위에서 표현된 것처럼 그보다 더 간단한 원시적인 식에서 만들어질 수 있다.
> 정규표현식 이론과 현식 적용에 대한 더 자세한 내용을 알고 싶다면 위에 언급된 Friedl의 책을 찾아보거나 컴파일러 구성론에 관한 어떤 책이라도 찾아보기 바란다.